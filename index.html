<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯ãƒ»ã‚µãƒã‚¤ãƒãƒ¼ v5.2.0 (æœ€çµ‚çµ±åˆç‰ˆ)</title>
<style>
  /* ã‚¹ã‚¿ã‚¤ãƒ«ã¯å¤‰æ›´ãªã— */
  body { margin: 0; overflow: hidden; background: #1a1a1a; color: white; font-family: 'Hiragino Kaku Gothic ProN', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; }
  
  /* UIè¡¨ç¤º */
  #hud { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; text-shadow: 1px 1px 0 #000; font-weight: bold; }
  .bar-container { width: 150px; height: 10px; background: #444; border: 1px solid #fff; margin-bottom: 5px; position: relative; }
  .bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
  #hp-bar { background: #ff4444; }
  #exp-bar { background: #00d2ff; width: 0%; }
  #event-message { color: gold; font-size: 18px; text-align: center; margin-top: 5px; }

  /* ã‚¤ãƒ™ãƒ³ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ  */
  #event-animation-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background-color: transparent;
    pointer-events: none;
    opacity: 0;
    z-index: 15; 
    transition: opacity 0.1s ease-out;
  }
  .event-flash {
    animation: flash-fade 0.5s ease-out forwards;
  }
  @keyframes flash-fade {
    0% { opacity: 0.8; }
    100% { opacity: 0; }
  }
  
  /* ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ç”»é¢ */
  #levelup-screen { 
    display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0,0,0,0.85); z-index: 20; flex-direction: column; justify-content: center; align-items: center;
  }
  #levelup-title { font-size: 30px; color: gold; margin-bottom: 20px; animation: pulse 1s infinite alternate; }
  .card-container { display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px; }
  .card { 
    background: #333; border: 2px solid #fff; padding: 15px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; 
    transition: transform 0.1s;
  }
  .card:active { transform: scale(0.98); background: #444; }
  .card-icon { width: 40px; height: 40px; background: #555; margin-right: 15px; display: flex; justify-content: center; align-items: center; font-size: 20px; border-radius: 5px;}
  .card-info h3 { margin: 0 0 5px 0; font-size: 18px; color: #ffeb3b; }
  .card-info p { margin: 0; font-size: 12px; color: #ccc; }
  .rarity-rare { border-color: gold; background: #442200; }
  .inventory-display {
    background: #111; padding: 10px; border-radius: 5px; margin-bottom: 20px;
    width: 90%; max-width: 400px; text-align: center;
  }
  .inv-list-item { display: inline-block; margin: 0 5px; font-size: 14px; }

  @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
</style>
</head>
<body>

<div id="hud">
  <div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div>
  <div class="bar-container" style="border-color: #00d2ff;"><div id="exp-bar" class="bar-fill"></div></div>
  <div>LV: <span id="lv-text">1</span> | TIME: <span id="time-text">00:00</span></div>
  <div>KILL: <span id="kill-text">0</span> | LUCK: <span id="luck-text">1%</span></div>
  <div>EVASION: <span id="evasion-text">0%</span></div>
  <div id="event-message"></div>
  <div id="boss-hp-bar" class="bar-container" style="display: none; width: 90vw; position: fixed; bottom: 10px; left: 5vw; height: 15px; border-color: red;">
      <div id="boss-hp-fill" class="bar-fill" style="background: red;"></div>
  </div>
</div>

<div id="event-animation-overlay"></div>

<div id="levelup-screen">
    <div id="levelup-title">LEVEL UP!</div>
    <div class="inventory-display" id="current-inventory"></div>
    <div class="card-container" id="card-list"></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
// --- ã‚²ãƒ¼ãƒ è¨­å®šãƒ»å®šæ•° ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const MAP_SIZE = 10000; 
const BOSS_HP_BAR = document.getElementById('boss-hp-bar');
const BOSS_HP_FILL = document.getElementById('boss-hp-fill');
const BULLET_QUEEN_COOLDOWN = 90; // BulletQueenBossã®å¼¾ç™ºå°„é–“éš” (1.5ç§’)   
const TELEPORT_COOLDOWN = 180; // TeleportHunterBossã®ãƒ†ãƒ¬ãƒãƒ¼ãƒˆé–“éš” (3ç§’)   
const TELEPORT_WARNING_FRAMES = 60; // ãƒ†ãƒ¬ãƒãƒ¼ãƒˆè­¦å‘Šç·šã‚’è¡¨ç¤ºã™ã‚‹æ™‚é–“ (1ç§’)
const SLIDE_INERTIA = 0.98; // æ…£æ€§åŠ›ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°æ™‚ã®æ¸›é€Ÿã®å¼±ã•ï¼‰
const SLIDE_INPUT_CORRECTION = 0.02; // æ…£æ€§åŠ›ã¸ã®å…¥åŠ›è£œæ­£ã®å‰²åˆ


function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
const rnd = (n) => Math.floor(Math.random() * n);
const rad = (d) => d * Math.PI / 180;

// Worldåº§æ¨™ã‚’Screenåº§æ¨™ã«å¤‰æ›ã™ã‚‹é–¢æ•°
const getScreenX = (x) => x - player.x + canvas.width / 2;
const getScreenY = (y) => y - player.y + canvas.height / 2;

// æœ€ã‚‚è¿‘ã„æ•µã‚’å–å¾—ã™ã‚‹é–¢æ•°
function getNearestEnemy() {
  let nearest = null;
  let minD = Infinity;
  enemies.forEach(e => {
    let d = Math.hypot(e.x - player.x, e.y - player.y);
    if(d < minD) { minD = d; nearest = e; }
  });
  return { enemy: nearest, dist: minD };
}

// æ­¦å™¨IDã‹ã‚‰UPGRADESã®ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
function getWeaponItem(wepId) { return UPGRADES.find(u => u.type === 'wep' && u.wepId === wepId); }
function getStatItem(statId) { return UPGRADES.find(u => u.type === 'stat' && u.id === statId); }

// --- ãƒ‡ãƒ¼ã‚¿å®šç¾© ---

/// 1. å¼·åŒ–ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆ
const UPGRADES = [
  // æ­¦å™¨ (ID 0-14)
  { id: 'wand', type: 'wep', name: 'é­”æ³•ã®æ–', icon: 'ğŸª„', maxLv: 8, wepId: 0, range: 400, desc: 'é€£å°„é »åº¦ã€å¼¾é€ŸãŒå‘ä¸Šã€‚Lv3ã‹ã‚‰å¤ªã„ãƒ“ãƒ¼ãƒ ã«ï¼' },
  { id: 'knife', type: 'wep', name: 'æŠ•ã’ãƒŠã‚¤ãƒ•', icon: 'ğŸ”ª', maxLv: 8, wepId: 1, range: 300, desc: 'å¼¾é€Ÿã€ç™ºå°„æ•°ãŒå¢—åŠ ' },
  { id: 'axe', type: 'wep', name: 'æ–§', icon: 'ğŸª“', maxLv: 8, wepId: 2, range: 600, desc: 'é€²è¡Œæ–¹å‘ã«æ”¾ç‰©ç·šã‚’æãå¤§ããªå¼¾ã‚’å‡ºã™' },
  { id: 'cross', type: 'wep', name: 'åå­—æ¶', icon: 'âœï¸', maxLv: 8, wepId: 3, range: 450, desc: 'è¿½å°¾æ€§èƒ½ã€å¼¾é€ŸãŒå‘ä¸Š' },
  { id: 'garlic', type: 'wep', name: 'ãƒ‹ãƒ³ãƒ‹ã‚¯', icon: 'ğŸ§„', maxLv: 8, wepId: 4, range: 120, desc: 'ã‚ªãƒ¼ãƒ©ç¯„å›²ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå‘ä¸Š' },
  { id: 'bible', type: 'wep', name: 'è–æ›¸', icon: 'ğŸ“•', maxLv: 8, wepId: 5, range: 150, desc: 'å›è»¢æ•°ï¼ˆç™ºå°„æ•°ï¼‰ã€æŒç¶šæ™‚é–“ãŒå‘ä¸Š' },
  { id: 'fireWand', type: 'wep', name: 'ç‚ã®æ–', icon: 'ğŸ”¥', maxLv: 8, wepId: 6, range: 500, desc: 'ç«ã®ç‰ã®å¨åŠ›ã€çˆ†ç™ºç¯„å›²ãŒå‘ä¸Š' },
  { id: 'holyWater', type: 'wep', name: 'è–æ°´', icon: 'ğŸ’§', maxLv: 8, wepId: 7, range: 250, desc: 'ãƒ€ãƒ¡ãƒ¼ã‚¸åºŠã®æŒç¶šæ™‚é–“ã€å‡ºç¾é »åº¦å‘ä¸Š' },
  { id: 'lightning', type: 'wep', name: 'é›·ã®æŒ‡è¼ª', icon: 'âš¡', maxLv: 8, wepId: 8, range: 9999, desc: 'è½é›·ã®é€£é–æ•°ã€å¨åŠ›ãŒå‘ä¸Š' },
  { id: 'pentagram', type: 'wep', name: 'äº”èŠ’æ˜Ÿ', icon: 'â­', maxLv: 8, wepId: 9, range: 9999, desc: 'ç”»é¢å†…ã®æ•µã‚’HPå‰²åˆã§æ”»æ’ƒã™ã‚‹' },
  { id: 'sword', type: 'wep', name: 'å¤§å‰£', icon: 'âš”ï¸', maxLv: 8, wepId: 10, range: 180, desc: 'ãƒ‹ãƒ³ãƒ‹ã‚¯ã‚ˆã‚Šåºƒã„ç¯„å›²ã«å¼·åŠ›ãªä¸€æ’ƒ' },
  { id: 'boomerang', type: 'wep', name: 'ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³', icon: 'â†©ï¸', maxLv: 8, wepId: 11, range: 500, desc: 'ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ãŒ2/3å€ã«' },
  { id: 'drone', type: 'wep', name: 'ãƒ‰ãƒ­ãƒ¼ãƒ³', icon: 'ğŸš', maxLv: 8, wepId: 12, range: 300, desc: 'è‡ªå‹•æ”»æ’ƒã™ã‚‹ãŠä¾›ã‚’å¬å–š' },
  { id: 'mine', type: 'wep', name: 'åœ°é›·', icon: 'ğŸ’£', maxLv: 8, wepId: 13, range: 9999, desc: 'é€šéã—ãŸå ´æ‰€ã«åœ°é›·ã‚’è¨­ç½®' },
  { id: 'icicle', type: 'wep', name: 'æ°·æŸ±', icon: 'â„ï¸', maxLv: 8, wepId: 14, range: 600, desc: 'ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§åå°„å›æ•°ãŒ1å›è¿½åŠ ' },

  // ãƒ‘ãƒƒã‚·ãƒ–èƒ½åŠ› (MaxLv: 20)
  { id: 'dmg', type: 'stat', name: 'ã»ã†ã‚Œã‚“è‰', icon: 'ğŸ¥¬', maxLv: 20, baseDesc: 'æ”»æ’ƒãƒ€ãƒ¡ãƒ¼ã‚¸', unit: '%', apply: (p) => p.dmgMult += 0.1, val: 10 },
  { id: 'cd', type: 'stat', name: 'ç©ºã£ã½ã®æ›¸', icon: 'ğŸ“–', maxLv: 20, baseDesc: 'ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³', unit: '%', apply: (p) => p.cdMult *= 0.9, val: -10 },
  { id: 'area', type: 'stat', name: 'ãƒ­ã‚¦ã‚½ã‚¯', icon: 'ğŸ•¯ï¸', maxLv: 20, baseDesc: 'æ”»æ’ƒç¯„å›²', unit: '%', apply: (p) => p.areaMult += 0.15, val: 15 },
  { id: 'projSpeed', type: 'stat', name: 'è…•ç”²', icon: 'ğŸ¦¾', maxLv: 20, baseDesc: 'å¼¾é€Ÿ', unit: '%', apply: (p) => p.projSpeedMult += 0.1, val: 10 },
  { id: 'speed', type: 'stat', name: 'ç¿¼', icon: 'ğŸª½', maxLv: 20, baseDesc: 'ç§»å‹•é€Ÿåº¦', unit: '%', apply: (p) => p.speed *= 1.1, val: 10 },
  { id: 'maxhp', type: 'stat', name: 'ãƒãƒ¼ãƒˆ', icon: 'â¤ï¸', maxLv: 20, baseDesc: 'æœ€å¤§HP', unit: '', apply: (p) => { p.maxHp += 20; p.hp += 20; }, val: 20 },
  { id: 'armor', type: 'stat', name: 'é§', icon: 'ğŸ›¡ï¸', maxLv: 20, baseDesc: 'è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›', unit: '', apply: (p) => p.armor += 1, val: 1 },
  { id: 'luck', type: 'stat', name: 'ã‚¯ãƒ­ãƒ¼ãƒãƒ¼', icon: 'ğŸ€', maxLv: 20, baseDesc: 'é‹æ°—', unit: '%', apply: (p) => p.luck = Math.min(1.0, p.luck + 0.01), val: 1 },
  { id: 'magnet', type: 'stat', name: 'ç£çŸ³', icon: 'ğŸ§²', maxLv: 20, baseDesc: 'å›åç¯„å›²', unit: 'px', apply: (p) => p.magnet += 30, val: 30 },
  { id: 'amount', type: 'stat', name: 'è¤‡å†™ã®è¼ª', icon: 'ğŸ’', maxLv: 20, baseDesc: 'ç™ºå°„æ•°', unit: 'ç™º', apply: (p) => p.amount += 1, val: 1 },
  { id: 'range', type: 'stat', name: 'ã‚¹ã‚³ãƒ¼ãƒ—', icon: 'ğŸ”­', maxLv: 20, baseDesc: 'æ”»æ’ƒå°„ç¨‹', unit: '%', apply: (p) => p.rangeMult += 0.1, val: 10 },
  { id: 'evasion', type: 'stat', name: 'ãƒãƒ³ãƒˆ', icon: 'ğŸ¥¼', maxLv: 20, baseDesc: 'å›é¿ç‡ (æœ€å¤§60%)', unit: '%', apply: (p) => p.evasion = Math.min(0.6, p.evasion + 0.03), val: 3 },
  { id: 'regen', type: 'stat', name: 'ç”Ÿå‘½ã®ç ', icon: 'ğŸ’š', maxLv: 10, baseDesc: 'HPè‡ªå‹•å›å¾©', unit: '/ç§’', apply: (p) => p.regen += 1, val: 1 }
];
// 2. æ•µã®è¨­å®š (å¤‰æ›´ãªã—)
// 2. æ•µã®è¨­å®š
const ENEMY_TYPES = [
  { time: 0,  name: 'Bat',      hp: 10, speed: 1.0, size: 10, color: '#aa55ff', exp: 1, type: 'normal' },
  { time: 30, name: 'Skeleton', hp: 20, speed: 0.7, size: 12, color: '#dddddd', exp: 2, type: 'normal' },
  { time: 60, name: 'Zombie',   hp: 40, speed: 0.5, size: 14, color: '#4caf50', exp: 3, type: 'normal' },
  { time: 90, name: 'RangedShooter', hp: 30, speed: 0.4, size: 12, color: '#f44336', exp: 4, type: 'shooter' }, 
  { time: 120,name: 'Charger',  hp: 50, speed: 1.2, size: 16, color: '#ff9800', exp: 6, type: 'charger' }, 
  { time: 180,name: 'Exploder', hp: 30, speed: 1.5, size: 12, color: '#000000', exp: 4, type: 'exploder' }, 
  { time: 240,name: 'Splitter', hp: 60, speed: 0.6, size: 20, color: '#2196f3', exp: 8, type: 'splitter' }, 
  { time: 300,name: 'Mage',     hp: 100,speed: 0.7, size: 18, color: '#9c27b0', exp: 10, type: 'mage' }, 
  { time: 360,name: 'Reaper',   hp: 9999,speed: 3.5,size: 30, color: '#000000', exp: 100, type: 'boss' },
  { time: 420, name: 'BulletQueen', hp: 35000, speed: 0.5, size: 40, color: '#ff69b4', exp: 1000, type: 'BulletQueenBoss' },
  { time: 540, name: 'TeleportHunter', hp: 28000, speed: 2.5, size: 35, color: '#ffff00', exp: 800, type: 'TeleportHunterBoss' },
  { time: 660, name: 'ArcMage', hp: 40000, speed: 0.3, size: 45, color: '#00ccff', exp: 1200, type: 'ArcMageBoss' }
];

// 3. ç‰¹åˆ¥ãƒ‰ãƒ­ãƒƒãƒ—
const DROPS = [
  { type: 'coin', color: 'gold', size: 6, icon: 'ğŸ’°', effect: (p) => { score += 100; showFloat(p.x, p.y, "+100G", "gold"); } },
  { type: 'food', color: 'pink', size: 8, icon: 'ğŸ•', effect: (p) => { p.hp = Math.min(p.hp+30, p.maxHp); showFloat(p.x, p.y, "Heal!", "pink"); } },
  { type: 'bomb', color: 'black', size: 8, icon: 'ğŸ’£', effect: (p) => { enemies.forEach(e=>takeDamage(e, e.maxHp / 3)); showFloat(p.x, p.y, "BOOM! (-33%)", "red"); } },
  { type: 'freeze', color: 'cyan', size: 8, icon: 'â„ï¸', effect: (p) => { freezeTimer = 300; showFloat(p.x, p.y, "Freeze!", "cyan"); } },
  { type: 'meat', color: 'red', size: 8, icon: 'ğŸ¥©', effect: (p) => { p.hp = Math.min(p.hp + p.maxHp * 0.1, p.maxHp); showFloat(p.x, p.y, "Small Heal!", "lightpink"); } },
  { type: 'light', color: 'yellow', size: 8, icon: 'âœ¨', effect: (p) => { slowEnemyTimer = 3600; showFloat(p.x, p.y, "Slow Field!", "yellow"); } },
  { type: 'fullMagnet', color: 'blue', size: 8, icon: 'ğŸ§²', effect: (p) => { 
    items.filter(i => i.kind === 'exp').forEach(i => { i.x = p.x; i.y = p.y; }); 
    showFloat(p.x, p.y, "Exp Collect!", "lightblue"); 
  } },
  { type: 'chest', color: 'gold', size: 10, icon: 'ğŸ', effect: (p) => { showLevelUpScreen(true); showFloat(p.x, p.y, "Chest!", "gold"); } }
];

// --- ã‚²ãƒ¼ãƒ å¤‰æ•° (å¤‰æ›´ãªã—) ---
let player = { 
  x: 0, y: 0, size: 15, color: '#00d2ff', 
  hp: 100, maxHp: 100, exp: 0, nextExp: 10, lv: 1, 
  speed: 3, armor: 0, regen: 0, luck: 0.01, magnet: 80, greed: 1,
  dmgMult: 1.0, areaMult: 1.0, cdMult: 1.0, amount: 0, projSpeedMult: 1.0,
  rangeMult: 1.0, evasion: 0.0, 
  invincibleTimer: 0, 
  weapons: [ {id:0, lv:1, cd:0} ],
  statLv: {},
  lastMove: {x:0, y:0, angle: 0}, 
  postPauseTimer: 0,
  isSliding: false,
  levelUpDamageBoost: 1.0 
};
let bullets = [];
let enemyBullets = [];
let enemies = [];
let items = [];
let floaters = []; 
let score = 0;
let killCount = 0;
let frame = 0;
let gameTime = 0;
let isPaused = false;
let freezeTimer = 0;
let slowEnemyTimer = 0; 
let joystick = { active: false, sx:0, sy:0, cx:0, cy:0, dx:0, dy:0, lastMoveAngle: 0 }; 
let bossActive = false;
let bossHp = 0;
let bossMaxHp = 0;
let currentEvent = 'None';
let eventModifiers = { enemyDmgMult: 1.0, speedDamp: 1.0, expMult: 1.0, cdMult: 1.0 };
let meteorWarning = [];
let minEnemySpawnRate = 10; 


// 4. ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿
const GAME_EVENTS = [
    { time: 120, name: 'èµ¤ã„æœˆ', effect: () => { eventModifiers.enemyDmgMult = 1.5; }, color: 'rgba(255, 0, 0, 0.9)' },
    { time: 180, name: 'æ¿ƒã„éœ§', effect: () => { /* æç”»ã§å¯¾å¿œ */ }, color: 'rgba(50, 50, 50, 0.9)' },
    { time: 240, name: 'éš•çŸ³ã®é›¨', effect: () => { /* updateã§å¯¾å¿œ */ }, color: 'rgba(150, 50, 0, 0.9)' },
    { time: 300, name: 'æ°·æ²³ã®æµ·', effect: () => { player.isSliding = true; }, color: 'rgba(0, 100, 255, 0.9)' },
      { time: 359, name: 'æ°·æ²³ã®æµ·', effect: () => { player.isSliding = false; }, color: 'rgba(0, 0, 0, 0)' },
    { time: 360, name: 'é‰›ã®é›¨', effect: () => { /* ã‚¹ãƒãƒ¼ãƒ³ã§å¯¾å¿œ */ }, color: 'rgba(100, 100, 100, 0.9)' },
    { time: 420, name: 'é–‹æˆ¦', effect: () => { enemies = []; spawnBoss('BulletQueen'); bossActive = true; }, color: 'rgba(255, 100, 100, 0.9)' },
    { time: 500, name: 'å››é¢æ¥šæ­Œ', effect: () => { spawnAmbush(100); }, color: 'rgba(50, 50, 50, 0.9)' },
    { time: 540, name: 'é«˜é€Ÿè¥²æ’ƒ', effect: () => { enemies = []; spawnBoss('TeleportHunter'); bossActive = true; }, color: 'rgba(255, 255, 0, 0.8)' },
    { time: 600, name: 'æ™‚ã®æ­ªã¿', effect: () => { eventModifiers.cdMult = 0.5; }, color: 'rgba(100, 255, 100, 0.9)' },
    { time: 660, name: 'é­”å°ã®åµ', effect: () => { enemies = []; spawnBoss('ArcMage'); bossActive = true; }, color: 'rgba(0, 150, 255, 0.9)' },
    { time: 720, name: 'é—‡ã®ä¾µæ”»', effect: () => { ENEMY_TYPES.forEach(t => t.speed *= 1.1); }, color: 'rgba(0, 0, 0, 0.9)' },
    { time: 800, name: 'å¤©ä¸Šã®ç¥ç¦', effect: () => { eventModifiers.expMult = 2.0; }, color: 'rgba(255, 255, 255, 0.9)' },
];


// --- ãƒ­ã‚¸ãƒƒã‚¯é–¢æ•°ç¾¤ ---

function getWeaponBaseCD(id) {
  const cds = [40, 20, 60, 100, 60, 120, 80, 180, 300, 6000, 180, 45, 120, 300, 40]; 
  return cds[id] || 60;
}

function getWeaponRange(wepId) {
    const wepData = UPGRADES.find(u => u.wepId === wepId);
    return wepData ? wepData.range : 0;
}

function showFloat(x, y, txt, col) {
  floaters.push({ x: x, y: y, txt: txt, col: col, life: 60 });
}

function gameOver(win=false) {
  isPaused = true;
  let timeStr = `${Math.floor(gameTime/60).toString().padStart(2,'0')}:${(gameTime%60).toString().padStart(2,'0')}`;
  if (win) {
    alert(`GAME CLEAR!\nç”Ÿå­˜æ™‚é–“: ${timeStr}\næ’ƒç ´æ•°: ${killCount}`);
  } else {
    alert(`GAME OVER\nç”Ÿå­˜æ™‚é–“: ${timeStr}\næ’ƒç ´æ•°: ${killCount}`);
  }
  location.reload();
}

function updateHUD() {
  document.getElementById('lv-text').innerText = player.lv;
  let m = Math.floor(gameTime / 60);
  let s = gameTime % 60;
  document.getElementById('time-text').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  document.getElementById('kill-text').innerText = killCount;
  document.getElementById('luck-text').innerText = Math.floor(player.luck*100) + "%";
  document.getElementById('evasion-text').innerText = Math.floor(player.evasion*100) + "%";
  
  document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + "%";
  document.getElementById('exp-bar').style.width = (player.exp / player.nextExp * 100) + "%";
  
  if (bossActive) {
      BOSS_HP_BAR.style.display = 'block';
      BOSS_HP_FILL.style.width = (bossHp / bossMaxHp * 100) + "%";
  } else {
      BOSS_HP_BAR.style.display = 'none';
  }

  const currentEventData = GAME_EVENTS.find(e => e.time === gameTime);
  if (currentEventData) {
      currentEvent = currentEventData.name;
      document.getElementById('event-message').innerText = `EVENT: ${currentEvent}`;
      document.getElementById('event-animation-overlay').style.backgroundColor = currentEventData.color;
      document.getElementById('event-animation-overlay').classList.add('event-flash');
      currentEventData.effect(); // ã‚¤ãƒ™ãƒ³ãƒˆåŠ¹æœã‚’é©ç”¨
      setTimeout(() => {
          document.getElementById('event-animation-overlay').classList.remove('event-flash');
          document.getElementById('event-animation-overlay').style.backgroundColor = 'transparent';
      }, 500);
  } else if (gameTime % 60 === 0) {
      // ã‚¤ãƒ™ãƒ³ãƒˆçµ‚äº†æ™‚ã«ãƒªã‚»ãƒƒãƒˆãŒå¿…è¦ãªmodifierã‚’ãƒªã‚»ãƒƒãƒˆ
      if (currentEvent === 'èµ¤ã„æœˆ') eventModifiers.enemyDmgMult = 1.0;
      if (currentEvent === 'æ™‚ã®æ­ªã¿') eventModifiers.cdMult = 1.0;
      if (currentEvent === 'å¤©ä¸Šã®ç¥ç¦') eventModifiers.expMult = 1.0;
      if (currentEvent === 'æ°·æ²³ã®æµ·') player.isSliding = false;
      
      document.getElementById('event-message').innerText = '';
      currentEvent = 'None';
      eventModifiers.speedDamp = 1.0; 
  }
}

function dropItem(x, y, expVal) {
  items.push({ kind: 'exp', x: x, y: y, val: expVal });
  if (Math.random() < player.luck) {
    let rare = DROPS[rnd(DROPS.length)];
    items.push({ kind: 'drop', x: x, y: y, data: rare });
  }
}

function takeDamage(e, amount) {
  e.hp -= amount;
  showFloat(e.x, e.y, Math.floor(amount), "white");
  
  if (e.hp <= 0) {
    enemies = enemies.filter(x => x !== e);
    killCount++;
    
    // ç‰¹æ®Šãªæ•µã®æ­»äº¡æ™‚å‡¦ç†
    if(e.type === 'exploder') {
        let size = 100 * player.areaMult;
        showFloat(e.x, e.y, "BOOM!", "red");
        enemies.forEach(other => {
            if(Math.hypot(e.x-other.x, e.y-other.y) < size) takeDamage(other, 30 * player.dmgMult);
        });
    } 
    else if(e.type === 'splitter') {
        spawnEnemy('Bat', e.x + 10, e.y + 10);
        spawnEnemy('Bat', e.x - 10, e.y - 10);
    } 
    else if (e.type.includes('Boss')) {
        bossActive = false;
        dropItem(e.x, e.y, e.exp); 
        
        if (gameTime >= 660 && !enemies.some(boss => boss.type.includes('Boss'))) {
            gameOver(true);
        }
        return;
    }
    
    // é€šå¸¸æ•µã®ãƒ‰ãƒ­ãƒƒãƒ—
    dropItem(e.x, e.y, e.exp);
  }
}

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹é–¢æ•°ï¼ˆå›é¿åˆ¤å®šå«ã‚€ï¼‰
function takePlayerDamage(damage) {
    if (Math.random() < player.evasion) {
        showFloat(player.x, player.y, "MISS!", "yellow");
        return;
    }
    
    let dmg = Math.max(1, damage - player.armor); 
    player.hp -= dmg;
    showFloat(player.x, player.y, -dmg, "red");
    if (player.hp <= 0) gameOver();
}

// é›·æ¼”å‡ºï¼†ãƒ­ã‚¸ãƒƒã‚¯
function lightningEffect(target, baseDmg, maxChains) {
    let currentTarget = target;
    const targetsHit = new Set();
    targetsHit.add(currentTarget);

    for (let chain = 0; chain < 1 + maxChains; chain++) {
        if (!currentTarget) break;

        takeDamage(currentTarget, baseDmg);

        // æ´¾æ‰‹ãªæ¼”å‡º
        for(let i=0; i<3; i++) {
            floaters.push({ 
                x: currentTarget.x + rnd(currentTarget.size*2) - currentTarget.size, 
                y: currentTarget.y + rnd(currentTarget.size*2) - currentTarget.size, 
                txt: 'âš¡', 
                col: 'yellow', 
                life: 10 
            });
        }

        if (chain >= maxChains) break;

        // æ¬¡ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¦‹ã¤ã‘ã‚‹
        let nextTarget = null;
        let minD = Infinity;

        enemies.forEach(e => {
            if (!targetsHit.has(e)) {
                let d = Math.hypot(currentTarget.x - e.x, currentTarget.y - e.y);
                if (d < minD && d < 200) { // 200pxä»¥å†…ã®æ•µã«é€£é–
                    minD = d;
                    nextTarget = e;
                }
            }
        });

        if (nextTarget) {
            targetsHit.add(nextTarget);
            // è¦–è¦šçš„ãªé€£é–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            bullets.push({ 
                type: 'lightningChain', 
                x: currentTarget.x, y: currentTarget.y, 
                targetX: nextTarget.x, targetY: nextTarget.y, 
                life: 5, size: 2 
            });
            currentTarget = nextTarget;
        } else {
            break;
        }
    }
}


// â­ æ­¦å™¨ã®ç™ºå°„ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå…¨æ­¦å™¨ãƒ­ã‚¸ãƒƒã‚¯çµ±åˆï¼‰
function fireWeapon(w) {
  const count = 1 + player.amount;
  const baseDmg = 10;
  const dmg = baseDmg * player.dmgMult * (1 + (w.lv - 1) * 0.1);
  const baseProjSpeed = 7;
  const projSpeed = baseProjSpeed * player.projSpeedMult;

  const getDir = () => joystick.active ? Math.atan2(joystick.cy-joystick.sy, joystick.cx-joystick.sx) : player.lastMove.angle;

  let { enemy: target, dist: targetDist } = getNearestEnemy();
  let wepRange = getWeaponRange(w.id) * player.rangeMult * player.areaMult;

  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã„ãªã„ã€ã¾ãŸã¯å°„ç¨‹å¤–ã®å ´åˆã¯ç™ºå°„ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹æ­¦å™¨
  if (targetDist > wepRange && w.id !== 4 && w.id !== 9 && w.id !== 13 && w.id !== 12 && w.id !== 8 && w.id !== 5 && w.id !== 7) return;

  
  switch(w.id) {
    case 0: // é­”æ³•ã®æ– (Wand)
      for(let i=0; i<count; i++) {
        if(target) {
          let angle = Math.atan2(target.y - player.y, target.x - player.x);
          angle += (i - count/2) * 0.2;
          bullets.push({ type: 'normal', x: player.x, y: player.y, vx: Math.cos(angle)*projSpeed, vy: Math.sin(angle)*projSpeed, life: 60, dmg: dmg, size: 5 + w.lv, pierce: 1 });
        }
      }
      break;
    case 1: // æŠ•ã’ãƒŠã‚¤ãƒ• (Knife)
        for(let i=0; i<count; i++) {
            if(target) {
                let angle = Math.atan2(target.y - player.y, target.x - player.x);
                angle += (i - count/2) * rad(10);
                bullets.push({ type: 'knife', x: player.x, y: player.y, vx: Math.cos(angle)*projSpeed*1.5, vy: Math.sin(angle)*projSpeed*1.5, life: 40, dmg: dmg, size: 4, pierce: 1 });
            }
        }
        break;
case 2: { // æ–§ (Axe)
        // â˜… é€²è¡Œæ–¹å‘ã¸ç™ºå°„ã—ã€æ”¾ç‰©ç·šï¼ˆé‡åŠ›ï¼‰ã‚’åŠ ãˆã‚‹
        const currentMoveAngle = getDir(); 
        const initialSpeed = projSpeed * 1.5;
        const gravityDirection = (Math.random() < 0.5 ? 1 : -1);
        
        bullets.push({ 
            type: 'axe', 
            x: player.x, y: player.y, 
            vx: Math.cos(currentMoveAngle) * initialSpeed, 
            vy: Math.sin(currentMoveAngle) * initialSpeed, 
            life: 60, dmg: dmg * 1.5, 
            size: 16 * player.areaMult, // â˜… ã‚µã‚¤ã‚ºã‚’2å€ (8 -> 16)
            pierce: 2, rot: 0,
            gravity: gravityDirection * (0.1 + 0.1 * Math.random()) // ãƒ©ãƒ³ãƒ€ãƒ ãªä¸Šä¸‹åŠ é€Ÿåº¦
        });
        break;
    }
    case 3: // åå­—æ¶ (Cross)
        if(target) {
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            let crossSpeed = projSpeed * 0.7;
            bullets.push({ type: 'cross', x: player.x, y: player.y, vx: Math.cos(angle)*crossSpeed, vy: Math.sin(angle)*crossSpeed, life: 80, dmg: dmg*1.2, size: 6, pierce: 99, target: target });
        }
        break;
    case 4: // ãƒ‹ãƒ³ãƒ‹ã‚¯ (Garlic)
        // ãƒ‹ãƒ³ãƒ‹ã‚¯ã¯ä¸€åº¦å–å¾—ã™ã‚‹ã¨ã€æ°¸ç¶šçš„ãªã‚ªãƒ¼ãƒ©å¼¾ã¨ã—ã¦ `bullets` ã«å­˜åœ¨ã™ã‚‹ã€‚
        // ã“ã“ã§ã¯ã¾ã ãƒ‹ãƒ³ãƒ‹ã‚¯å¼¾ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã¿ç”Ÿæˆã™ã‚‹ã€‚
        if (!bullets.some(b => b.type === 'garlic')) {
            let garlicSize = 50 + w.lv * 15 * player.areaMult;
            bullets.push({ type: 'garlic', x: player.x, y: player.y, dmg: dmg, size: garlicSize, life: Infinity, pierce: 99 });
        } else {
             // ã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ç¯„å›²ã¨å¨åŠ›ã‚’æ›´æ–°ï¼ˆã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã¯å˜ãªã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã¨ã—ã¦æ©Ÿèƒ½ï¼‰
            let garlic = bullets.find(b => b.type === 'garlic');
            garlic.size = 50 + w.lv * 15 * player.areaMult;
            garlic.dmg = dmg;
        }
        break;
    case 5: { // è–æ›¸ (Bible)
        const numBibles = 1 + Math.floor(w.lv / 2);
        for(let i=0; i<numBibles; i++) {
            const existingBible = bullets.find(b => b.type === 'bible' && b.instance === i);
            if (!existingBible) {
                bullets.push({ 
                    type: 'bible', instance: i, 
                    x: player.x, y: player.y, 
                    dmg: dmg, size: 10 * player.areaMult, 
                    life: 180 + w.lv * 30, pierce: 99, 
                    angle: (Math.PI * 2 / numBibles) * i,
                    radius: 40 + w.lv * 5 * player.areaMult,
                    speed: 1 + w.lv * 0.1,
                    lastHit: new Map() // å€‹åˆ¥ãƒ’ãƒƒãƒˆãƒãƒƒãƒ—
                });
            }
        }
        break;
    }
    case 6: // ç‚ã®æ– (FireWand)
        if(target) {
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            let fireSpeed = projSpeed * 1.2;
            let explosionSize = 50 + w.lv * 10 * player.areaMult;
            bullets.push({ type: 'fire', x: player.x, y: player.y, vx: Math.cos(angle)*fireSpeed, vy: Math.sin(angle)*fireSpeed, life: 40, dmg: dmg, size: 6, pierce: 1, explosionSize: explosionSize });
        }
        break;
    case 7: { // è–æ°´ (HolyWater)
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•æ–¹å‘ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«ã€ä¸€å®šç¯„å›²å†…ã«è¨­ç½®
        const randomAngle = Math.random() * Math.PI * 2;
        const radius = 100 * player.rangeMult;
        
        let waterX = player.x + Math.cos(randomAngle) * radius;
        let waterY = player.y + Math.sin(randomAngle) * radius;

        let waterSize = 60 * player.areaMult;
        let waterDuration = 180 + w.lv * 30;

        bullets.push({ type: 'holyWater', x: waterX, y: waterY, dmg: dmg*0.5, size: waterSize, life: waterDuration, pierce: 99, lastHit: new Map() });
        break;
    }
    case 8: // é›·ã®æŒ‡è¼ª (Lightning)
        if (target) {
            // é›·ã®é€£é–ã®èµ·ç‚¹
            lightningEffect(target, dmg * (1 + w.lv * 0.5), w.lv); 
        }
        break;
    case 9: // äº”èŠ’æ˜Ÿ (Pentagram)
        // ç”»é¢å…¨ä½“æ”»æ’ƒ
        enemies.forEach(e => takeDamage(e, e.maxHp)); // å³æ­»
        showFloat(player.x, player.y, "PURGE!", "red");
        break;
    case 10: // å‰£ (Sword)
        if(target) {
             let swordAngle = Math.atan2(target.y - player.y, target.x - player.x);
             let swingRange = wepRange;
             // æŒç¶šæ™‚é–“10ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‰£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
             bullets.push({ 
                 type: 'sword', 
                 x: player.x, y: player.y, 
                 dmg: dmg * 3, 
                 size: swingRange, 
                 angle: swordAngle, 
                 life: 10, 
                 pierce: 99, 
                 hitEnemies: new Set() 
             });
        }
        break;
    case 11: // ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³ (Boomerang)
        if(target) {
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            bullets.push({ 
                type: 'boomerang', 
                x: player.x, y: player.y, 
                vx: Math.cos(angle)*projSpeed, vy: Math.sin(angle)*projSpeed, 
                life: 180, dmg: dmg, size: 8, pierce: 1 + w.lv, 
                originX: player.x, originY: player.y, 
                return: false 
            });
        }
        break;
    case 12: // ãƒ‰ãƒ­ãƒ¼ãƒ³ (Drone)
        // æ­¦å™¨ãƒ‰ãƒ­ãƒ¼ãƒ³è‡ªä½“ã‚’æ°¸ç¶šå¼¾ã¨ã—ã¦å­˜åœ¨ã•ã›ã‚‹
        if (!bullets.some(b => b.type === 'drone')) {
            bullets.push({ type: 'drone', x: player.x, y: player.y, dmg: dmg, size: 10, life: Infinity, pierce: 99, cdTimer: 0 });
        } else {
             // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å¨åŠ›ã‚’æ›´æ–°
            let drone = bullets.find(b => b.type === 'drone');
            drone.dmg = dmg;
        }
        break;
    case 13: // åœ°é›· (Mine)
        // ç§»å‹•ã—ãŸç›´å¾Œã«åœ°é›·ã‚’è¨­ç½®
        const mineLifetime = 360 + w.lv * 60;
        const explosionSize = 50 * player.areaMult;
        bullets.push({ 
            type: 'mine', 
            x: player.x, y: player.y, 
            dmg: dmg * 5, 
            size: 8, 
            life: mineLifetime, 
            pierce: 99, 
            isTriggered: false,
            explosionSize: explosionSize
        });
        break;
    case 14: // æ°·æŸ± (Icicle)
        if (target) {
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            bullets.push({ 
                type: 'icicle', 
                x: player.x, y: player.y, 
                vx: Math.cos(angle)*projSpeed, vy: Math.sin(angle)*projSpeed, 
                life: 60, dmg: dmg, size: 5, 
                pierce: 1 + w.lv, // åå°„å›æ•°ã‚‚å…¼ã­ã‚‹
                lastHit: new Map(), 
                reflectionCount: 0 
            });
        }
        break;
  }
}


function spawnEnemy(typeOverride, startX, startY) {
  let type;
  if (typeOverride) {
    type = ENEMY_TYPES.find(t => t.name === typeOverride);
  } else {
    let availableTypes = ENEMY_TYPES.filter(t => t.time <= gameTime && t.type !== 'boss' && t.name !== 'Reaper' && !t.type.includes('Boss'));
    
    if (currentEvent === 'é‰›ã®é›¨') {
        availableTypes = availableTypes.filter(t => t.type === 'shooter' || t.type === 'mage');
    }

    let idx = rnd(availableTypes.length);
    type = availableTypes[idx];
  }
  
  if (!type) return;

  let angle = Math.random() * Math.PI * 2;
  let dist = Math.max(canvas.width, canvas.height) / 2 + 100;
  
  let baseHp = type.hp * (1 + gameTime*0.01);

  enemies.push({ 
    x: startX !== undefined ? startX : player.x + Math.cos(angle) * dist, 
    y: startY !== undefined ? startY : player.y + Math.sin(angle) * dist, 
    hp: baseHp,
    maxHp: baseHp,
    speed: type.speed, 
    color: type.color, 
    exp: type.exp,
    type: type.type,
    size: type.size, 
    state: 'move', // move, idle, charge
    cd: 0,
    chargeTimer: 0,
    chargeAngle: 0
  });
}

function spawnBoss(name) {
    const bossData = ENEMY_TYPES.find(t => t.name === name);
    if (!bossData) return;

    const angle = rnd(360) * rad(1);
    const radius = Math.max(canvas.width, canvas.height) / 2 + 100;
    const bossX = player.x + Math.cos(angle) * radius;
    const bossY = player.y + Math.sin(angle) * radius;

    const newBoss = {
        x: bossX, y: bossY, 
        hp: bossData.hp, maxHp: bossData.hp, 
        speed: bossData.speed, 
        size: bossData.size, 
        color: bossData.color, 
        exp: bossData.exp, 
        type: bossData.type,
        typeData: bossData,
        cd: 0,
        state: 'move', // move, idle, charge
        patternTimer: 0, 
        attackPhase: 0,
        tempAngle: 0,
        vx: 0, vy: 0 
    };
    enemies.push(newBoss);
    bossHp = newBoss.hp;
    bossMaxHp = newBoss.maxHp;
    bossActive = true;
}

function fireEnemyBullet(e, isBoss=false, angle=0, type='normal', speedMult=1.0) {
    let targetAngle = angle || Math.atan2(player.y - e.y, player.x - e.x);
    let speed = (isBoss ? 5 : 4) * speedMult;
    let dmg = isBoss ? 15 : 5;
    
    enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(targetAngle)*speed, vy: Math.sin(targetAngle)*speed, size: 5, dmg: dmg, type: type, life: 300 });
}

// é›‘é­šæ•µã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã«å¤§é‡ã«å¬å–š
function spawnAmbush(count) {
    const radius = 500;
    for(let i=0; i<count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * radius;
        spawnEnemy('Bat', player.x + Math.cos(angle) * dist, player.y + Math.sin(angle) * dist);
    }
    showFloat(player.x, player.y, "Ambush!", "red");
}

function getUpgradeDescription(upgrade) {
    if (upgrade.type === 'wep') {
        let lv = player.weapons.find(w => w.id === upgrade.wepId)?.lv || 0;
        let next = lv + 1;
        let desc = upgrade.desc;
        if (lv === 0) return `[æ–°è¦] ${upgrade.name}: ${desc}`;
        if (lv < upgrade.maxLv) return `[Lv${lv}â†’${next}] ${upgrade.name}: æ€§èƒ½ãŒå‘ä¸Š`;
        return `[MAX Lv${lv}] ${upgrade.name}: æ—¢ã«æœ€å¤§ã§ã™ã€‚`;
    } else {
        let lv = player.statLv[upgrade.id] || 0;
        let next = lv + 1;
        if (lv < upgrade.maxLv) return `[Lv${lv}â†’${next}] ${upgrade.name}: ${upgrade.baseDesc} ${upgrade.unit === '%' ? '+' : ''}${upgrade.val}${upgrade.unit}`;
        return `[MAX Lv${lv}] ${upgrade.name}: æ—¢ã«æœ€å¤§ã§ã™ã€‚`;
    }
}

function selectUpgrade(upgrade) {
    isPaused = false;
    document.getElementById('levelup-screen').style.display = 'none';

    if (upgrade.type === 'wep') {
        let existingWep = player.weapons.find(w => w.id === upgrade.wepId);
        if (existingWep) {
            if (existingWep.lv < upgrade.maxLv) existingWep.lv++;
        } else {
            player.weapons.push({ id: upgrade.wepId, lv: 1, cd: 0 });
        }
    } else {
        let currentLv = player.statLv[upgrade.id] || 0;
        if (currentLv < upgrade.maxLv) {
            upgrade.apply(player);
            player.statLv[upgrade.id] = currentLv + 1;
        }
    }
}

function checkLevelUp() {
    while (player.exp >= player.nextExp) {
        player.exp -= player.nextExp;
        player.lv++;
        player.nextExp = Math.floor(player.nextExp * 1.2) + 5;
        showLevelUpScreen();
        return;
    }
}

function showLevelUpScreen() {
    isPaused = true;
    document.getElementById('levelup-screen').style.display = 'flex';
    const cardList = document.getElementById('card-list');
    cardList.innerHTML = '';

    const availableUpgrades = getAvailableUpgrades();
    const chosen = [];
    
    while (chosen.length < 3 && availableUpgrades.length > 0) {
        const index = rnd(availableUpgrades.length);
        chosen.push(availableUpgrades[index]);
        availableUpgrades.splice(index, 1);
    }
    
    chosen.forEach(upgrade => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
            <div class="card-icon">${upgrade.icon}</div>
            <div class="card-info">
                <h3>${upgrade.name}</h3>
                <p>${getUpgradeDescription(upgrade)}</p>
            </div>
        `;
        card.onclick = () => selectUpgrade(upgrade);
        cardList.appendChild(card);
    });

    const invDiv = document.getElementById('current-inventory');
    invDiv.innerHTML = 'è£…å‚™: ';
    player.weapons.forEach(w => {
        const item = getWeaponItem(w.id);
        invDiv.innerHTML += `<span class="inv-list-item">${item.icon} Lv${w.lv}</span>`;
    });
}

function getAvailableUpgrades() {
    const available = [];
    UPGRADES.forEach(u => {
        let currentLv = u.type === 'wep' 
            ? player.weapons.find(w => w.id === u.wepId)?.lv || 0
            : player.statLv[u.id] || 0;

        if (currentLv < u.maxLv) {
            available.push(u);
        }
    });
    
    const priority = [];
    player.weapons.forEach(w => {
        const item = getWeaponItem(w.id);
        if (item && w.lv < item.maxLv) priority.push(item);
    });
    Object.keys(player.statLv).forEach(statId => {
        const item = getStatItem(statId);
        if (item && player.statLv[statId] < item.maxLv) priority.push(item);
    });

    let list = available;
    priority.forEach(p => {
        list.push(p, p, p);
    });
    
    return list;
}


// --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
function init() {
  player.x = 0; 
  player.y = 0;
  loop();
}

function loop() {
  if (!isPaused) {
    update();
  }
  draw();
  requestAnimationFrame(loop);
}

function update() {

  if (freezeTimer > 0) freezeTimer--;
  if (slowEnemyTimer > 0) slowEnemyTimer--;

  // 0. ã‚¤ãƒ™ãƒ³ãƒˆ 'éš•çŸ³ã®é›¨' ã®å‡¦ç†
  if (currentEvent === 'éš•çŸ³ã®é›¨' && frame % 15 === 0) {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨è¾ºã«äºˆå‘Šå††ã‚’è¿½åŠ 
    const numMeteors = 3;
    for (let i = 0; i < numMeteors; i++) {
      let offsetX = (Math.random() - 0.5) * 600;
      let offsetY = (Math.random() - 0.5) * 600;

      meteorWarning.push({
        x: player.x + offsetX,
        y: player.y + offsetY,
        radius: 50,
        timer: 60
      });
    }
  }

  // 1. ç§»å‹• (æ…£æ€§/ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè£…)
  // æ…£æ€§ç§»å‹•ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ï¼‰ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒç‰¹å¾´çš„
  let inputDx = 0, inputDy = 0;
  let moveX = 0, moveY = 0;

  if (joystick.active) {

    if (player.isSliding) {
      inputDx = joystick.cx - joystick.sx;
      inputDy = joystick.cy - joystick.sy;

      let angle = Math.atan2(inputDy, inputDx);
      let dist = Math.min(50, Math.hypot(inputDx, inputDy));

      // æ…£æ€§åŠ› (SLIDE_INERTIA: 98%) + å…¥åŠ›è£œæ­£åŠ› (SLIDE_INPUT_CORRECTION: 2%)
      joystick.dx = joystick.dx * SLIDE_INERTIA + Math.cos(angle) * dist * SLIDE_INPUT_CORRECTION;
      joystick.dy = joystick.dy * SLIDE_INERTIA + Math.sin(angle) * dist * SLIDE_INPUT_CORRECTION;

    } else {
      joystick.dx = joystick.cx - joystick.sx;
      joystick.dy = joystick.cy - joystick.sy;
    }

    if (joystick.dx !== 0 || joystick.dy !== 0) {
      player.lastMove.angle = Math.atan2(joystick.dy, joystick.dx);
    }
  } else if (player.isSliding) {
    // æ…£æ€§ã®ã¿: æ¸›é€Ÿã‚’å¼±ã (å¼·åŒ–)
    joystick.dx *= SLIDE_INERTIA;
    joystick.dy *= SLIDE_INERTIA;
  } else {
    // é€šå¸¸åœæ­¢: å³åº§ã«åœæ­¢
    joystick.dx = 0;
    joystick.dy = 0;
  }

  let currentSpeed = Math.hypot(joystick.dx, joystick.dy);
  let maxSpeed = 50;
  if (currentSpeed > maxSpeed) {
    let ratio = maxSpeed / currentSpeed;
    joystick.dx *= ratio;
    joystick.dy *= ratio;
  }

  let finalSpeed = player.speed * (currentSpeed / maxSpeed);

  let nextX = player.x + joystick.dx / maxSpeed * finalSpeed;
  let nextY = player.y + joystick.dy / maxSpeed * finalSpeed;

  player.x = Math.max(-MAP_SIZE / 2, Math.min(MAP_SIZE / 2, nextX));
  player.y = Math.max(-MAP_SIZE / 2, Math.min(MAP_SIZE / 2, nextY));

  // 2. æ­¦å™¨ã®ç™ºå°„åˆ¶å¾¡
  player.weapons.forEach(w => {
    if (w.cd > 0) w.cd--;
    else {
      fireWeapon(w);
      w.cd = getWeaponBaseCD(w.id) * player.cdMult * eventModifiers.cdMult;
    }
  });

  // 3. å¼¾ã®ç§»å‹• & å¯¿å‘½ (å‘³æ–¹)
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];

    const baseProjSpeed = 7;
    const projSpeed = baseProjSpeed * player.projSpeedMult;

    if (b.type === 'boomerang') {
      let maxDist = getWeaponRange(11) * player.rangeMult * player.areaMult;
      let currentDist = Math.hypot(b.x - b.originX, b.y - b.originY);

      if (b.return) {
        let angle = Math.atan2(player.y - b.y, player.x - b.x);
        b.vx = Math.cos(angle) * projSpeed;
        b.vy = Math.sin(angle) * projSpeed;
      } else if (currentDist > maxDist) {
        b.return = true;
      }

      b.x += b.vx; b.y += b.vy;

      if (b.return && Math.hypot(b.x - player.x, b.y - player.y) < player.size) {
        bullets.splice(i, 1);
        continue;
      }

    }
    else if (b.type === 'drone') {
      let { enemy: target, dist: targetDist } = getNearestEnemy();
      b.x = player.x; b.y = player.y;
      b.cdTimer = b.cdTimer || 0;
      b.cdTimer++;

      let droneRange = getWeaponRange(12) * player.rangeMult * player.areaMult;
      if (target && targetDist < droneRange && b.cdTimer % 30 === 0) {
        let angle = Math.atan2(target.y - b.y, target.x - b.x);
        bullets.push({ type: 'normal', x: b.x, y: b.y, vx: Math.cos(angle) * projSpeed, vy: Math.sin(angle) * projSpeed, life: 30, dmg: b.dmg, size: 3, pierce: 1 });
      }
    }
    else if (b.type === 'mine') {
      if (!b.isTriggered) {
        enemies.forEach(e => {
          if (Math.hypot(b.x - e.x, b.y - e.y) < b.size + e.size) {
            b.isTriggered = true;
            showFloat(b.x, b.y, "MINE!", "orange");
            enemies.forEach(other => {
              if (Math.hypot(b.x - other.x, b.y - other.y) < b.explosionSize) takeDamage(other, b.dmg);
            });
            bullets.splice(i, 1);
          }

        });
      }
    }
    else if (b.type === 'sword') {
      // å‰£ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿½å¾“
      b.x = player.x;
      b.y = player.y;
    }
    else if (b.type === 'bible') {
      b.angle += b.speed * 0.01;
      b.x = player.x + Math.cos(b.angle) * b.radius;
      b.y = player.y + Math.sin(b.angle) * b.radius;
    }
    else if (b.type === 'garlic') {
      b.x = player.x; b.y = player.y;
    }
    else if (b.type !== 'holyWater' && b.type !== 'lightningChain') {
      b.x += b.vx * player.projSpeedMult;
      b.y += b.vy * player.projSpeedMult;

      if (b.type === 'axe') { b.vy += 0.3; b.rot = (b.rot || 0) + 0.2; }

      if (b.type === 'cross' && b.target) {
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ­»ã‚“ã§ã„ãŸã‚‰æœ€ã‚‚è¿‘ã„æ•µã«åˆ‡ã‚Šæ›¿ãˆ
        if (enemies.includes(b.target)) {
          let angle = Math.atan2(b.target.y - b.y, b.target.x - b.x);
          b.vx = Math.cos(angle) * projSpeed * 0.7;
          b.vy = Math.sin(angle) * projSpeed * 0.7;
        } else {
          let { enemy: newTarget } = getNearestEnemy();
          b.target = newTarget;
          if (!newTarget) b.life = 0; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã„ãªã‘ã‚Œã°æ¶ˆæ»…
        }
      }
    }

    b.life--;
    if (b.life <= 0) {
      if (b.type === 'fire' && !b.isExploded) {
        // ç«ã®ç‰ãŒå¯¿å‘½ã‚’è¿ãˆãŸã¨ãã«çˆ†ç™º
        enemies.forEach(e => {
          if (Math.hypot(b.x - e.x, b.y - e.y) < b.explosionSize) takeDamage(e, b.dmg * 2);
        });
        showFloat(b.x, b.y, "ğŸ”¥Explode", "red");
      }

      bullets.splice(i, 1);
    }
  }

  // 4. æ•µã®ç”Ÿæˆ & ç§»å‹•
  let enemySpeedMult = 1.0;
  if (freezeTimer > 0) enemySpeedMult = 0;
  if (slowEnemyTimer > 0) enemySpeedMult *= (2 / 3);

  let baseSpawnRate = Math.max(minEnemySpawnRate, 60 - Math.floor(gameTime / 15));
  if (currentEvent === 'é—‡ã®ä¾µæ”»') baseSpawnRate /= 2;

  if (enemySpeedMult > 0) {
    if (!bossActive && gameTime < 420) {
      if (frame % baseSpawnRate === 0) spawnEnemy();
    }

    enemies.forEach(e => {
      let dist = Math.hypot(player.x - e.x, player.y - e.y);
      let angle = Math.atan2(player.y - e.y, player.x - e.x);
      e.cd = e.cd || 0;
      e.cd++;

      let moveSpeed = e.speed * enemySpeedMult;

      // â˜… ãƒœã‚¹ã®ç‰¹æ®Šå‡¦ç† (è¤‡é›‘ãªæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ç®¡ç†)
      if (e.type.includes('Boss') || e.name === 'Reaper') {
        bossHp = e.hp; bossMaxHp = e.maxHp;
        e.cd = e.cd || 0;
        e.cd++;
        e.patternTimer = e.patternTimer || 0;
        e.attackPhase = e.attackPhase || 0;
        e.tempAngle = e.tempAngle || 0;

        // Reaper (å³æ­»ãƒœã‚¹)
        if (e.name === 'Reaper') {
          e.x += Math.cos(angle) * moveSpeed;
          e.y += Math.sin(angle) * moveSpeed;
          if (dist < player.size + e.size) gameOver(); // æ¥è§¦ã§å³æ­»
          return;
        }


        // --- BulletQueenBoss å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ ---
        if (e.type === 'BulletQueenBoss') {
          e.patternTimer++;
            let newX = player.x + (Math.random() - 0.5) * 1000;
            let newY = player.y + (Math.random() - 0.5) * 1000;
          if (e.attackPhase === 0) { // æ¥è¿‘ãƒ•ã‚§ãƒ¼ã‚º
            e.x += Math.cos(angle) * moveSpeed;
            e.y += Math.sin(angle) * moveSpeed;
            if (dist < 400 || e.patternTimer > 180) {
              e.attackPhase = rnd(4) + 1; // 1-4ã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ”»æ’ƒã«ç§»è¡Œ
              e.patternTimer = 0;
              e.tempAngle = Math.random() * Math.PI * 2;
            }
          }
          else if (e.attackPhase === 1) { // æ‹¡æ•£å¼¾ãƒ•ã‚§ãƒ¼ã‚º (360åº¦ãƒ©ãƒ³ãƒ€ãƒ å°„æ’ƒ)
            e.x += Math.cos(angle) * moveSpeed * 0.1;
            if (e.patternTimer % 5 === 0 && e.patternTimer < 120) {
              const numBullets = 8;
              for (let i = 0; i < numBullets; i++) {
                let randomAngle = Math.random() * Math.PI * 2;
                fireEnemyBullet(e, true, randomAngle);
              }
            } else if (e.patternTimer >= 180) {
              e.attackPhase = 0;
              e.patternTimer = 0;
            }
          }
          else if (e.attackPhase === 2) { // æ‰‡çŠ¶å¼¾ãƒ•ã‚§ãƒ¼ã‚º (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‹™ã„)
            e.x += Math.cos(angle) * moveSpeed * 0.1;
            if (e.patternTimer % 30 === 0 && e.patternTimer < 180) {
              const numFan = 5;
              const spread = rad(30);
              for (let i = 0; i < numFan; i++) {
                let fanAngle = angle + (i - (numFan - 1) / 2) * (spread / (numFan - 1));
                fireEnemyBullet(e, true, fanAngle);
              }
            } else if (e.patternTimer >= 240) {
              e.attackPhase = 0;
              e.patternTimer = 0;
            }
          }
          else if (e.attackPhase === 3) { // ãƒ©ãƒ³ãƒ€ãƒ é€£ç¶šå¼¾
            if (e.patternTimer < 180 && e.patternTimer % 3 === 0) {
              const randomDir = Math.random() * Math.PI * 2;
              fireEnemyBullet(e, true, randomDir, 'normal', 1.5);
            } else if (e.patternTimer >= 240) {
              e.attackPhase = 0;
              e.patternTimer = 0;
            }
          }
          else if (e.attackPhase === 4) { // è¿½å°¾å¼¾ï¼‹ã‚¶ã‚³å¬å–š
            if (e.patternTimer === 1) { // å¬å–š
              for (let i = 0; i < 4; i++) {
                let spawnAngle = (Math.PI * 2 / 4) * i;
                spawnEnemy('Bat', e.x + Math.cos(spawnAngle) * e.size * 2, e.y + Math.sin(spawnAngle) * e.size * 2);
              }
              showFloat(e.x, e.y, "Minion Summon!", "yellow");
            }
            if (e.patternTimer % 45 === 0 && e.patternTimer < 180) { // è¿½å°¾å¼¾
              fireEnemyBullet(e, true, angle, 'homing', 0.5);
              fireEnemyBullet(e, true, angle + rad(15), 'homing', 0.5);
              fireEnemyBullet(e, true, angle - rad(15), 'homing', 0.5);
            } else if (e.patternTimer >= 240) {
              e.attackPhase = 0;
              e.patternTimer = 0;
            }
          }
        }

        // --- TeleportHunterBoss å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ ---
        else if (e.type === 'TeleportHunterBoss') {
          e.patternTimer++;
          
          if (e.patternTimer < 60) {
            // äºˆå‚™å‹•ä½œ (ç§»å‹•)
            e.x += Math.cos(angle) * moveSpeed * 0.5;
            e.y += Math.sin(angle) * moveSpeed * 0.5;
          } else if (e.patternTimer === 60) {
            // ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ
            let newX = player.x + (Math.random() - 0.5) * 1000;
            let newY = player.y + (Math.random() - 0.5) * 1000;
            e.x = newX;
            e.y = newY;
            showFloat(e.x, e.y, "Teleport!", "cyan");
          } else if (e.patternTimer > 60 && e.patternTimer < 180 && e.patternTimer % 10 === 0) {
            // ä¹±å°„
            const numShots = 3;
            for (let i = 0; i < numShots; i++) {
              let randomAngle = angle + (Math.random() - 0.5) * rad(90);
              fireEnemyBullet(e, true, randomAngle, 'normal', 1.2);
            }
          } else if (e.patternTimer > 240) {
            e.patternTimer = 0; // ãƒªã‚»ãƒƒãƒˆ
          }
        }

        // --- ArcMageBoss å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ ---
        else if (e.type === 'ArcMageBoss') {
          e.patternTimer++;
          if (e.patternTimer < 120) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç‹™ã£ãŸå¤§å¼¾
            if (e.patternTimer % 60 === 0) {
              fireEnemyBullet(e, true, angle, 'big', 0.5); // é€Ÿåº¦é…ã‚ã€ã‚µã‚¤ã‚ºå¤§ãã‚
            }
          } else if (e.patternTimer >= 120 && e.patternTimer < 360) {
            // å›è»¢ã™ã‚‹å¼¾å¹•
            if (e.patternTimer % 10 === 0) {
              e.tempAngle += rad(5); // å›è»¢
              for (let i = 0; i < 4; i++) {
                fireEnemyBullet(e, true, e.tempAngle + (Math.PI / 2) * i);
              }
            }
          } else if (e.patternTimer > 360) {
            e.patternTimer = 0;
            e.tempAngle = 0;
          }
        }

        return;
      }

      // ç‰¹æ®Šãªæ•µã®å‹•ä½œ
      if (e.type === 'shooter' || e.type === 'mage') {
        const SHOOT_RANGE = 300;
        const PADDING = 50;

        if (dist > SHOOT_RANGE) {
          e.x += Math.cos(angle) * moveSpeed;
          e.y += Math.sin(angle) * moveSpeed;
          e.state = 'move';
        } else if (dist < SHOOT_RANGE - PADDING) {
          let awayAngle = angle + Math.PI;
          e.x += Math.cos(awayAngle) * moveSpeed * 0.5;
          e.y += Math.sin(awayAngle) * moveSpeed * 0.5;
          e.state = 'retreat';
        } else {
          e.state = 'idle';
          let shootCD = e.type === 'shooter' ? 90 : 60;
          if (e.cd % shootCD === 0) { fireEnemyBullet(e); }
        }
        return;
      }

      if (e.type === 'charger') {
        const CHARGE_DELAY = 90;
        const CHARGE_SPEED = moveSpeed * 4;

        if (e.state === 'move' && e.cd > CHARGE_DELAY) {
          e.chargeAngle = angle;
          e.state = 'charge';
          e.cd = 0;
        } else if (e.state === 'charge' && e.cd < 60) {
          e.x += Math.cos(e.chargeAngle) * CHARGE_SPEED;
          e.y += Math.sin(e.chargeAngle) * CHARGE_SPEED;
        } else if (e.state === 'charge' && e.cd >= 60) {
          e.state = 'move';
          e.cd = 0;
        } else {
          e.x += Math.cos(angle) * moveSpeed;
          e.y += Math.sin(angle) * moveSpeed;
        }
        return;
      }

      // --- é€šå¸¸æ•µã®å‹•ã (normal, exploder, splitter) ---
      e.x += Math.cos(angle) * moveSpeed;
      e.y += Math.sin(angle) * moveSpeed;

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸
      if (dist < player.size + e.size) {
        if (frame % 30 === 0) {
          takePlayerDamage(10 * eventModifiers.enemyDmgMult);
        }
      }
    });
  }

  // 4.5. æ•µå¼¾ã®ç§»å‹•ã¨åˆ¤å®š
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    let eb = enemyBullets[i];

    if (eb.type === 'homing') {
      // è¿½å°¾ãƒ­ã‚¸ãƒƒã‚¯
      let angle = Math.atan2(player.y - eb.y, player.x - eb.x);
      let speed = Math.hypot(eb.vx, eb.vy);

      let currentAngle = Math.atan2(eb.vy, eb.vx);
      let diff = angle - currentAngle;
      if (diff > Math.PI) diff -= Math.PI * 2;
      if (diff < -Math.PI) diff += Math.PI * 2;

      let turnRate = 0.05;
      currentAngle += Math.min(Math.max(diff, -turnRate), turnRate);

      eb.vx = Math.cos(currentAngle) * speed;
      eb.vy = Math.sin(currentAngle) * speed;
    }

    eb.x += eb.vx;
    eb.y += eb.vy;
    eb.life--;

    let dist = Math.hypot(eb.x - player.x, eb.y - player.y);
    if (dist < eb.size + player.size) {
      takePlayerDamage(eb.dmg || 5);
      enemyBullets.splice(i, 1);
      continue;
    }

    if (eb.life <= 0) {
      enemyBullets.splice(i, 1);
    }
  }

  // 4.7. Garlic/HolyWater ã®å¸¸æ™‚ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
  const garlicBullet = bullets.find(b => b.type === 'garlic');
  const holyWaterBullets = bullets.filter(b => b.type === 'holyWater');

  if (garlicBullet && frame % 10 === 0) {
    enemies.forEach(e => {
      let dist = Math.hypot(garlicBullet.x - e.x, garlicBullet.y - e.y);
      if (dist < garlicBullet.size + e.size) {
        takeDamage(e, garlicBullet.dmg * 0.16);
      }
    });
  }

  if (holyWaterBullets.length > 0 && frame % 15 === 0) {
    holyWaterBullets.forEach(b => {
      enemies.forEach(e => {
        let dist = Math.hypot(b.x - e.x, b.y - e.y);
        if (dist < b.size + e.size) {
          if (!b.lastHit.has(e) || frame - b.lastHit.get(e) > 30) {
            takeDamage(e, b.dmg);
            b.lastHit.set(e, frame);
          }
        }
      });
    });
  }

  // 4.8. éš•çŸ³ã®ç€å¼¾å‡¦ç†
  for (let i = meteorWarning.length - 1; i >= 0; i--) {
    let m = meteorWarning[i];
    m.timer--;

    if (m.timer <= 0) {
      // éš•çŸ³ç€å¼¾ï¼
      enemies.forEach(e => {
        let dist = Math.hypot(m.x - e.x, m.y - e.y);
        if (dist < m.radius * 2) { // ç¯„å›²æ‹¡å¤§
          takeDamage(e, 50 * player.dmgMult);
        }
      });
      let playerDist = Math.hypot(m.x - player.x, m.y - player.y);
      if (playerDist < m.radius) {
        takePlayerDamage(20);
      }
      showFloat(m.x, m.y, "METEOR!", "red");
      meteorWarning.splice(i, 1);
    }
  }


  // 5. å½“ãŸã‚Šåˆ¤å®šï¼ˆå‘³æ–¹å¼¾ -> æ•µï¼‰
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    let hit = false;

    // å¸¸æ™‚åŠ¹æœã®å¼¾ã¯ã‚¹ã‚­ãƒƒãƒ—
    if (b.type === 'garlic' || b.type === 'holyWater' || b.type === 'mine' || b.type === 'drone' || b.type === 'lightningChain') continue;

    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      let dist = Math.hypot(b.x - e.x, b.y - e.y);

      // å…±é€šã®ãƒ’ãƒƒãƒˆåˆ¤å®š
      if (dist < b.size + e.size || b.type === 'sword') {

        if (b.type === 'sword') {
          // å‰£ã®å½“ãŸã‚Šåˆ¤å®š: æ‰‡å½¢ã®ç¯„å›²å†…åˆ¤å®š
          let dx = e.x - b.x;
          let dy = e.y - b.y;
          let enemyAngle = Math.atan2(dy, dx);

          let startAngle = b.angle - rad(20);
          let endAngle = b.angle + rad(20);

          // è§’åº¦ã®æ­£è¦åŒ– (è¤‡é›‘ãªè§’åº¦å‡¦ç†ã‚’å›é¿ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ç°¡æ˜“åˆ¤å®š)
          let isNearAngle = Math.abs(enemyAngle - b.angle) < rad(30);

          if (Math.hypot(dx, dy) < b.size + e.size && isNearAngle) {
            if (b.hitEnemies.has(e)) continue;

            takeDamage(e, b.dmg);
            b.hitEnemies.add(e);
          }
          continue;
        }

        if (b.type === 'bible') {
          if (b.lastHit.has(e) && frame - b.lastHit.get(e) < 10) continue;
          b.lastHit.set(e, frame);
        }

        if (b.type === 'icicle') {
          if (b.lastHit.has(e) && frame - b.lastHit.get(e) < 5) continue;
          b.lastHit.set(e, frame);

          b.pierce--;
          if (b.pierce >= 0) {
            const baseProjSpeed = 7;
            const projSpeed = baseProjSpeed * player.projSpeedMult;

            const nextTarget = enemies.find(other => other !== e && !b.lastHit.has(other));
            if (nextTarget) {
              let angle = Math.atan2(nextTarget.y - b.y, nextTarget.x - b.x);
              b.vx = Math.cos(angle) * projSpeed;
              b.vy = Math.sin(angle) * projSpeed;
              b.reflectionCount++;
            } else {
              b.pierce = 0;
            }
          }
        }

        takeDamage(e, b.dmg);
        b.pierce = (b.pierce || 1) - 1;

        if (b.pierce <= 0) {
          hit = true;
          break;
        }
      }
    }

    if (hit && b.type !== 'axe' && b.type !== 'cross' && b.type !== 'bible' && b.type !== 'boomerang' && b.type !== 'icicle') {
      bullets.splice(i, 1);
    }
  }

  // 6. çµŒé¨“å€¤ãƒ»ã‚¢ã‚¤ãƒ†ãƒ å›å (å¤‰æ›´ãªã—)
  for (let i = items.length - 1; i >= 0; i--) {
    let it = items[i];
    let dist = Math.hypot(it.x - player.x, it.y - player.y);

    let isVisible = getScreenX(it.x) > -500 && getScreenX(it.x) < canvas.width + 500 &&
      getScreenY(it.y) > -500 && getScreenY(it.y) < canvas.height + 500;

    let isMagnetized = dist < player.magnet || !isVisible;

    if (isMagnetized) {
      let angle = Math.atan2(player.y - it.y, player.x - it.x);
      it.x += Math.cos(angle) * 8;
      it.y += Math.sin(angle) * 8;
    }

    if (dist < player.size + 5) {
      if (it.kind === 'exp') {
        player.exp += it.val * eventModifiers.expMult;
        checkLevelUp();
      } else if (it.kind === 'drop') {
        it.data.effect(player);
      }
      items.splice(i, 1);
    }
  }

  // 7. å®šæœŸå›å¾©ã¨æ™‚é–“æ›´æ–° & ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
  if (frame % 60 === 0) {
    gameTime++;
    updateHUD();

    if (player.regen > 0) player.hp = Math.min(player.maxHp, player.hp + player.regen);
  }

  // 8. ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆã®æ›´æ–° (å¤‰æ›´ãªã—)
  for (let i = floaters.length - 1; i >= 0; i--) {
    floaters[i].life--;
    floaters[i].y -= 1;
    if (floaters[i].life <= 0) floaters.splice(i, 1);
  }

  frame++;
}
// --- æç”»å‡¦ç† (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»å¼·åŒ–ã€ãƒ‹ãƒ³ãƒ‹ã‚¯åˆæœŸã‚ªãƒ¼ãƒ©æç”»æŠ‘æ­¢) ---
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 1. èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ (å¤‰æ›´ãªã—)
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  const gridSize = 100;
  const offsetX = (player.x % gridSize) - canvas.width / 2;
  const offsetY = (player.y % gridSize) - canvas.height / 2;
  
  for (let i = -canvas.width / gridSize / 2 - 1; i < canvas.width / gridSize / 2 + 2; i++) {
    ctx.beginPath();
    ctx.moveTo(i * gridSize - offsetX, 0);
    ctx.lineTo(i * gridSize - offsetX, canvas.height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i * gridSize - offsetY);
    ctx.lineTo(canvas.width, i * gridSize - offsetY);
    ctx.stroke();
  }
  
  // 2. æ•µ (å››è§’å½¢) (å¤‰æ›´ãªã—)
  enemies.forEach(e => {
    let screenX = getScreenX(e.x);
    let screenY = getScreenY(e.y);
    let size = e.size * 1.5; 
    
    ctx.fillStyle = e.color;
    ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
    
    // HP Bar
    ctx.fillStyle = '#444';
    ctx.fillRect(screenX - size/2, screenY - size/2 - 8, size, 3);
    ctx.fillStyle = 'red';
    ctx.fillRect(screenX - size/2, screenY - size/2 - 8, (e.hp / e.maxHp) * size, 3);
  });
  
  // 3. çµŒé¨“å€¤ãƒ»ã‚¢ã‚¤ãƒ†ãƒ  (å¤‰æ›´ãªã—)
  items.forEach(it => {
    let screenX = getScreenX(it.x);
    let screenY = getScreenY(it.y);
    
    ctx.beginPath();
    ctx.arc(screenX, screenY, it.size || 5, 0, Math.PI * 2);
    ctx.fillStyle = it.kind === 'exp' ? '#00d2ff' : it.data.color;
    ctx.fill();
    
    if (it.kind === 'drop') {
      ctx.fillStyle = 'white';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(it.data.icon, screenX, screenY + 4);
    }
  });

  // 4. å‘³æ–¹å¼¾ãƒ»æ­¦å™¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ 
  bullets.forEach(b => {
    let screenX = getScreenX(b.x);
    let screenY = getScreenY(b.y);
    
    ctx.save();
    ctx.translate(screenX, screenY);
    
    switch(b.type) {
      case 'normal':
        ctx.fillStyle = 'white';
        ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size);
        break;
      case 'knife':
        ctx.fillStyle = '#ccc';
        ctx.rotate(Math.atan2(b.vy, b.vx));
        ctx.fillRect(0, -1, b.size * 2, 2);
        break;
      case 'axe':
        ctx.fillStyle = '#8b4513';
        ctx.rotate(b.rot);
        ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size);
        break;
      case 'cross':
        ctx.fillStyle = 'yellow';
        ctx.font = '14px Arial';
        ctx.fillText('âœ', -5, 5);
        break;
      case 'garlic':
        // â˜… ãƒ‹ãƒ³ãƒ‹ã‚¯ã‚ªãƒ¼ãƒ©ã®æç”»: å­˜åœ¨ã™ã‚‹å ´åˆã®ã¿æç”»
        if (player.weapons.some(w => w.id === 4)) {
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3 + (Math.sin(frame * 0.1) * 0.1);
            ctx.beginPath();
            ctx.arc(0, 0, b.size, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        break;
      case 'bible':
        ctx.fillStyle = 'gold';
        ctx.font = '12px Arial';
        ctx.fillText('ğŸ“–', -6, 5);
        break;
      case 'fire':
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.arc(0, 0, b.size, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'holyWater':
        ctx.fillStyle = 'rgba(0, 150, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(0, 0, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'blue';
        ctx.stroke();
        break;
      case 'sword': 
        ctx.fillStyle = `rgba(255, 255, 255, ${b.life / 10})`;
        ctx.rotate(b.angle);
        ctx.beginPath();
        ctx.arc(0, 0, b.size, -rad(20), rad(20)); 
        ctx.lineTo(0,0);
        ctx.fill();
        ctx.strokeStyle = 'silver';
        ctx.lineWidth = 3;
        ctx.stroke();
        break;
      case 'boomerang':
        ctx.fillStyle = 'lime';
        ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size); 
        break;
      case 'drone':
        ctx.fillStyle = 'green';
        ctx.font = '12px Arial';
        ctx.fillText('ğŸš', -6, 5);
        break;
      case 'mine':
        ctx.fillStyle = b.isTriggered ? 'red' : 'gray';
        ctx.beginPath();
        ctx.arc(0, 0, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText('ğŸ’£', 0, 4);
        break;
      case 'icicle':
        ctx.fillStyle = 'cyan';
        ctx.fillRect(-b.size/2, -b.size/2, b.size, b.size); 
        break;
      case 'lightningChain':
        ctx.strokeStyle = `rgba(255, 255, 0, ${b.life / 5})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(getScreenX(b.targetX) - screenX, getScreenY(b.targetY) - screenY);
        ctx.stroke();
        break;
    }
    ctx.restore();
  });
  
  // 5. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (è¦–èªæ€§å‘ä¸Šãƒ‘ãƒƒãƒé©ç”¨ & ç”»è³ªæ”¹å–„)
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);

  // è¼ªéƒ­ç·š (é»’ã„ç¸å–ã‚Šã§èƒŒæ™¯è‰²ã¨åŒºåˆ¥ - å…ˆã«æç”»ã—ã¦å†…å´ã‚’å¡—ã‚Šã¤ã¶ã™)
  ctx.beginPath();
  ctx.arc(0, 0, player.size, 0, Math.PI * 2);
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“ (ãƒã‚ªãƒ³ã‚«ãƒ©ãƒ¼ã§å¼·èª¿)
  ctx.fillStyle = player.color; // #00d2ff
  ctx.beginPath();
  ctx.arc(0, 0, player.size, 0, Math.PI * 2);
  ctx.fill();


  // å›åç¯„å›² (ãƒã‚°ãƒãƒƒãƒˆ)
  ctx.strokeStyle = 'rgba(0, 255, 0, 0)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, player.magnet, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
  
  // 6. æ•µå¼¾ (å››è§’å½¢)
  enemyBullets.forEach(eb => {
    let screenX = getScreenX(eb.x);
    let screenY = getScreenY(eb.y);
    let size = eb.size * (eb.type === 'big' ? 3 : 1);
    
    ctx.fillStyle = eb.type === 'homing' ? 'purple' : 'red';
    ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
  });
  
  // 7. éš•çŸ³ã®è­¦å‘Šå††
  meteorWarning.forEach(m => {
    let screenX = getScreenX(m.x);
    let screenY = getScreenY(m.y);
    
    ctx.strokeStyle = `rgba(255, 0, 0, ${m.timer / 60})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(screenX, screenY, m.radius, 0, Math.PI * 2);
    ctx.stroke();
  });


  // 8. ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
  floaters.forEach(f => {
    ctx.fillStyle = f.col;
    ctx.globalAlpha = f.life / 60;
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(f.txt, getScreenX(f.x), getScreenY(f.y));
  });
  ctx.globalAlpha = 1.0;
  
  // 9. ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ (å¤‰æ›´ãªã—)
  if (joystick.active) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(joystick.sx, joystick.sy, 50, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.beginPath();
    ctx.arc(joystick.cx, joystick.cy, 20, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- å…¥åŠ›å‡¦ç† (å¤‰æ›´ãªã—) ---
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (isPaused) return;
    const touch = e.touches[0];
    joystick.active = true;
    joystick.sx = touch.clientX;
    joystick.sy = touch.clientY;
    joystick.cx = touch.clientX;
    joystick.cy = touch.clientY;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!joystick.active || isPaused) return;
    const touch = e.touches[0];
    let dx = touch.clientX - joystick.sx;
    let dy = touch.clientY - joystick.sy;
    const dist = Math.hypot(dx, dy);
    const maxDist = 50;

    if (dist > maxDist) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDist;
        dy = Math.sin(angle) * maxDist;
    }
    joystick.cx = joystick.sx + dx;
    joystick.cy = joystick.sy + dy;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    if (e.touches.length === 0) {
        joystick.active = false;
    }
});

let keys = {};

document.addEventListener('keydown', (e) => {
    if (isPaused) return;
    keys[e.key] = true;

    joystick.active = true;
    
    let newDx = 0, newDy = 0;
    const speed = 50; 

    if (keys['ArrowUp'] || keys['w']) newDy -= speed;
    if (keys['ArrowDown'] || keys['s']) newDy += speed;
    if (keys['ArrowLeft'] || keys['a']) newDx -= speed;
    if (keys['ArrowRight'] || keys['d']) newDx += speed;

    if (newDx !== 0 || newDy !== 0) {
        joystick.cx = joystick.sx + newDx;
        joystick.cy = joystick.sy + newDy;
        
        if (!player.isSliding) {
            joystick.dx = newDx;
            joystick.dy = newDy;
            player.lastMove.angle = Math.atan2(newDy, newDx);
        }
    }
});

document.addEventListener('keyup', (e) => {
    delete keys[e.key];

    if (Object.keys(keys).length === 0) {
        joystick.active = false;
    }
});


init();
</script>
</body>
</html>
</body>
</html>
